import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';

# Connectors

The first thing to do when writing a Buttplug application is figuring out how to talk to a Buttplug
Server (like [Intiface Central](/docs/dev-guide/architecture/intiface.md)). For sake of simplicity,
we'll cover websockets in this part of the manual, as this is by far the most common method of
connecting clients and servers. Other connection situations and solutions (WebRTC, iroh, etc...) are
covered in the [cookbook](/docs/dev-guide/cookbook/intro.md) section.

## Websocket Connectors

Websockets are the default connector transport for Buttplug. They work as both a transport for
desktop applications and web browsers, and have implementations available in most programming
popular languages. As the library does not send many messages (maybe 50 per second in busy cases),
the overhead of websockets isn't really an issue for the library.

Client implementations made by the Buttplug Core Team will provide a websocket connector for you.
You should be able to create the connector, define the server address, and use that to connect. For
using Websocket servers, you'll need to provide the user a way to pass in the server address (as
this will not always exist on the same machine your software is running on), then you just create
the connector object using that address.

:::tip The Accidental Standard Port of 12345

When Buttplug's first public server came out in 2017, it used port 12345 as a test value. This stuck
with the system, so now most applications that use Intiface or Buttplug use port 12345 for
connection by default. Some client applications have gone as far as to hardcore the value, but this
is not recommended.

This can sometimes be an issue for users running certain software that collides with the port. [We
have some recommended fixes in the Intiface Central 
Documentation.](https://docs.intiface.com/docs/intiface-central/troubleshooting#checking-for-other-programs-that-collide-network-ports)
:::

<Tabs groupId="examples">
<TabItem value="rust" label="Rust">

import RustExternalConnectorExample from '!!raw-loader!/examples/v4/rust/external_connector.rs';

<CodeBlock language="rust">{RustExternalConnectorExample}</CodeBlock>

</TabItem>
<TabItem value="csharp" label="C#">

import CSharpExternalConnectorExample from '!!raw-loader!/examples/v4/csharp/RemoteConnectorExample/Program.cs';

<CodeBlock language="csharp">{CSharpExternalConnectorExample}</CodeBlock>

</TabItem>
<TabItem value="js" label="Javascript">

import jsExternalConnectorExample from '!!raw-loader!/examples/v4/javascript/remote-connector-example.js';

<CodeBlock language="js">{jsExternalConnectorExample}</CodeBlock>

</TabItem>
<TabItem value="python" label="Python">

import PythonConnectionExample from '!!raw-loader!/examples/v4/python/connection.py';

<CodeBlock language="python">{PythonConnectionExample}</CodeBlock>

</TabItem>
</Tabs>

### Security Considerations

Due to basically being impossible to deal with, [Intiface
Engine/Central](/docs/dev-guide/architecture/intiface.md) does not implement SSL websockets (wss).
This required self-signed certificates which rarely worked correctly and caused end-user confusion.
Non-secured websockets work for Intiface Central instances running on the same host as web apps, due
to localhost security exceptions. Remote browser connections (i.e. browser on desktop, intiface
central on phone) may fail due to security requirements. Intiface Central provides a [Repeater
Mode](https://docs.intiface.com/docs/intiface-central/ui/app-modes-repeater-panel) (basically a
proxy) to work with instances where web browsers on a machine other than the Intiface Central is
accessing hardware.
